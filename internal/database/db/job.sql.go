// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createJob = `-- name: CreateJob :one
INSERT INTO jobs (
    user_id,
    title,
    company_name,
    notes,
    link,
    location,
    platform,
    date_applied,
    status
) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, user_id, title, company_name, notes, link, location, platform, date_applied, status, created_at, updated_at
`

type CreateJobParams struct {
	UserID      int32            `json:"user_id"`
	Title       string           `json:"title"`
	CompanyName *string          `json:"company_name"`
	Notes       *string          `json:"notes"`
	Link        *string          `json:"link"`
	Location    *string          `json:"location"`
	Platform    *string          `json:"platform"`
	DateApplied pgtype.Timestamp `json:"date_applied"`
	Status      string           `json:"status"`
}

func (q *Queries) CreateJob(ctx context.Context, arg CreateJobParams) (Job, error) {
	row := q.db.QueryRow(ctx, createJob,
		arg.UserID,
		arg.Title,
		arg.CompanyName,
		arg.Notes,
		arg.Link,
		arg.Location,
		arg.Platform,
		arg.DateApplied,
		arg.Status,
	)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CompanyName,
		&i.Notes,
		&i.Link,
		&i.Location,
		&i.Platform,
		&i.DateApplied,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteJobByID = `-- name: DeleteJobByID :exec
DELETE FROM jobs
WHERE id = $1
`

func (q *Queries) DeleteJobByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteJobByID, id)
	return err
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, user_id, title, company_name, notes, link, location, platform, date_applied, status, created_at, updated_at FROM jobs
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetJobByID(ctx context.Context, id int32) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.CompanyName,
		&i.Notes,
		&i.Link,
		&i.Location,
		&i.Platform,
		&i.DateApplied,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getJobs = `-- name: GetJobs :many
SELECT id, user_id, title, company_name, notes, link, location, platform, date_applied, status, created_at, updated_at FROM jobs
WHERE user_id = $1
`

func (q *Queries) GetJobs(ctx context.Context, userID int32) ([]Job, error) {
	rows, err := q.db.Query(ctx, getJobs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.CompanyName,
			&i.Notes,
			&i.Link,
			&i.Location,
			&i.Platform,
			&i.DateApplied,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateJobByID = `-- name: UpdateJobByID :exec
UPDATE jobs
SET
    title = COALESCE($2::text, title),
    company_name = COALESCE($3::text, company_name),
    notes = COALESCE($4::text, notes),
    link = COALESCE($5::text, link),
    location = COALESCE($6::text, location),
    platform = COALESCE($7::text, platform),
    date_applied = COALESCE($8::timestamp, date_applied),
    status = COALESCE($9::text, status),
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, title, company_name, notes, link, location, platform, date_applied, status, created_at, updated_at
`

type UpdateJobByIDParams struct {
	ID          int32            `json:"id"`
	Title       *string          `json:"title"`
	CompanyName *string          `json:"company_name"`
	Notes       *string          `json:"notes"`
	Link        *string          `json:"link"`
	Location    *string          `json:"location"`
	Platform    *string          `json:"platform"`
	DateApplied pgtype.Timestamp `json:"date_applied"`
	Status      *string          `json:"status"`
}

func (q *Queries) UpdateJobByID(ctx context.Context, arg UpdateJobByIDParams) error {
	_, err := q.db.Exec(ctx, updateJobByID,
		arg.ID,
		arg.Title,
		arg.CompanyName,
		arg.Notes,
		arg.Link,
		arg.Location,
		arg.Platform,
		arg.DateApplied,
		arg.Status,
	)
	return err
}
